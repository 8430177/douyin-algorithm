// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: argus.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_argus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_argus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_argus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_argus_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_argus_2eproto;
class ActionRecord;
struct ActionRecordDefaultTypeInternal;
extern ActionRecordDefaultTypeInternal _ActionRecord_default_instance_;
class Argus;
struct ArgusDefaultTypeInternal;
extern ArgusDefaultTypeInternal _Argus_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ActionRecord* Arena::CreateMaybeMessage<::ActionRecord>(Arena*);
template<> ::Argus* Arena::CreateMaybeMessage<::Argus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Argus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Argus) */ {
 public:
  inline Argus() : Argus(nullptr) {}
  ~Argus() override;
  explicit PROTOBUF_CONSTEXPR Argus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Argus(const Argus& from);
  Argus(Argus&& from) noexcept
    : Argus() {
    *this = ::std::move(from);
  }

  inline Argus& operator=(const Argus& from) {
    CopyFrom(from);
    return *this;
  }
  inline Argus& operator=(Argus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Argus& default_instance() {
    return *internal_default_instance();
  }
  static inline const Argus* internal_default_instance() {
    return reinterpret_cast<const Argus*>(
               &_Argus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Argus& a, Argus& b) {
    a.Swap(&b);
  }
  inline void Swap(Argus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Argus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Argus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Argus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Argus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Argus& from) {
    Argus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Argus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Argus";
  }
  protected:
  explicit Argus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsAppIDFieldNumber = 4,
    kDeviceIDFieldNumber = 5,
    kLicenseIDFieldNumber = 6,
    kAppVersionFieldNumber = 7,
    kSdkVersionStrFieldNumber = 8,
    kEnvCodeFieldNumber = 10,
    kBodyHashFieldNumber = 13,
    kQueryHashFieldNumber = 14,
    kSecDeviceTokenFieldNumber = 16,
    kPskHashFieldNumber = 18,
    kPskCalHashFieldNumber = 19,
    kPskVersionFieldNumber = 20,
    kActionRecordFieldNumber = 15,
    kMagicFieldNumber = 1,
    kVersionFieldNumber = 2,
    kRandFieldNumber = 3,
    kSdkVersionFieldNumber = 9,
    kPlatformFieldNumber = 11,
    kCreateTimeFieldNumber = 12,
    kIsAppLicenseFieldNumber = 17,
    kCallTypeFieldNumber = 21,
  };
  // string msAppID = 4;
  void clear_msappid();
  const std::string& msappid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msappid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msappid();
  PROTOBUF_NODISCARD std::string* release_msappid();
  void set_allocated_msappid(std::string* msappid);
  private:
  const std::string& _internal_msappid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msappid(const std::string& value);
  std::string* _internal_mutable_msappid();
  public:

  // optional string deviceID = 5;
  bool has_deviceid() const;
  private:
  bool _internal_has_deviceid() const;
  public:
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string licenseID = 6;
  void clear_licenseid();
  const std::string& licenseid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_licenseid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_licenseid();
  PROTOBUF_NODISCARD std::string* release_licenseid();
  void set_allocated_licenseid(std::string* licenseid);
  private:
  const std::string& _internal_licenseid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_licenseid(const std::string& value);
  std::string* _internal_mutable_licenseid();
  public:

  // optional string appVersion = 7;
  bool has_appversion() const;
  private:
  bool _internal_has_appversion() const;
  public:
  void clear_appversion();
  const std::string& appversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appversion();
  PROTOBUF_NODISCARD std::string* release_appversion();
  void set_allocated_appversion(std::string* appversion);
  private:
  const std::string& _internal_appversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appversion(const std::string& value);
  std::string* _internal_mutable_appversion();
  public:

  // string sdkVersionStr = 8;
  void clear_sdkversionstr();
  const std::string& sdkversionstr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdkversionstr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdkversionstr();
  PROTOBUF_NODISCARD std::string* release_sdkversionstr();
  void set_allocated_sdkversionstr(std::string* sdkversionstr);
  private:
  const std::string& _internal_sdkversionstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdkversionstr(const std::string& value);
  std::string* _internal_mutable_sdkversionstr();
  public:

  // bytes envCode = 10;
  void clear_envcode();
  const std::string& envcode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_envcode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_envcode();
  PROTOBUF_NODISCARD std::string* release_envcode();
  void set_allocated_envcode(std::string* envcode);
  private:
  const std::string& _internal_envcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_envcode(const std::string& value);
  std::string* _internal_mutable_envcode();
  public:

  // optional bytes bodyHash = 13;
  bool has_bodyhash() const;
  private:
  bool _internal_has_bodyhash() const;
  public:
  void clear_bodyhash();
  const std::string& bodyhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bodyhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bodyhash();
  PROTOBUF_NODISCARD std::string* release_bodyhash();
  void set_allocated_bodyhash(std::string* bodyhash);
  private:
  const std::string& _internal_bodyhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bodyhash(const std::string& value);
  std::string* _internal_mutable_bodyhash();
  public:

  // optional bytes queryHash = 14;
  bool has_queryhash() const;
  private:
  bool _internal_has_queryhash() const;
  public:
  void clear_queryhash();
  const std::string& queryhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_queryhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_queryhash();
  PROTOBUF_NODISCARD std::string* release_queryhash();
  void set_allocated_queryhash(std::string* queryhash);
  private:
  const std::string& _internal_queryhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queryhash(const std::string& value);
  std::string* _internal_mutable_queryhash();
  public:

  // optional string secDeviceToken = 16;
  bool has_secdevicetoken() const;
  private:
  bool _internal_has_secdevicetoken() const;
  public:
  void clear_secdevicetoken();
  const std::string& secdevicetoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secdevicetoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secdevicetoken();
  PROTOBUF_NODISCARD std::string* release_secdevicetoken();
  void set_allocated_secdevicetoken(std::string* secdevicetoken);
  private:
  const std::string& _internal_secdevicetoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secdevicetoken(const std::string& value);
  std::string* _internal_mutable_secdevicetoken();
  public:

  // optional bytes pskHash = 18;
  bool has_pskhash() const;
  private:
  bool _internal_has_pskhash() const;
  public:
  void clear_pskhash();
  const std::string& pskhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pskhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pskhash();
  PROTOBUF_NODISCARD std::string* release_pskhash();
  void set_allocated_pskhash(std::string* pskhash);
  private:
  const std::string& _internal_pskhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pskhash(const std::string& value);
  std::string* _internal_mutable_pskhash();
  public:

  // optional bytes pskCalHash = 19;
  bool has_pskcalhash() const;
  private:
  bool _internal_has_pskcalhash() const;
  public:
  void clear_pskcalhash();
  const std::string& pskcalhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pskcalhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pskcalhash();
  PROTOBUF_NODISCARD std::string* release_pskcalhash();
  void set_allocated_pskcalhash(std::string* pskcalhash);
  private:
  const std::string& _internal_pskcalhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pskcalhash(const std::string& value);
  std::string* _internal_mutable_pskcalhash();
  public:

  // string pskVersion = 20;
  void clear_pskversion();
  const std::string& pskversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pskversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pskversion();
  PROTOBUF_NODISCARD std::string* release_pskversion();
  void set_allocated_pskversion(std::string* pskversion);
  private:
  const std::string& _internal_pskversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pskversion(const std::string& value);
  std::string* _internal_mutable_pskversion();
  public:

  // .ActionRecord actionRecord = 15;
  bool has_actionrecord() const;
  private:
  bool _internal_has_actionrecord() const;
  public:
  void clear_actionrecord();
  const ::ActionRecord& actionrecord() const;
  PROTOBUF_NODISCARD ::ActionRecord* release_actionrecord();
  ::ActionRecord* mutable_actionrecord();
  void set_allocated_actionrecord(::ActionRecord* actionrecord);
  private:
  const ::ActionRecord& _internal_actionrecord() const;
  ::ActionRecord* _internal_mutable_actionrecord();
  public:
  void unsafe_arena_set_allocated_actionrecord(
      ::ActionRecord* actionrecord);
  ::ActionRecord* unsafe_arena_release_actionrecord();

  // int32 magic = 1;
  void clear_magic();
  int32_t magic() const;
  void set_magic(int32_t value);
  private:
  int32_t _internal_magic() const;
  void _internal_set_magic(int32_t value);
  public:

  // int32 version = 2;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // int64 rand = 3;
  void clear_rand();
  int64_t rand() const;
  void set_rand(int64_t value);
  private:
  int64_t _internal_rand() const;
  void _internal_set_rand(int64_t value);
  public:

  // int32 sdkVersion = 9;
  void clear_sdkversion();
  int32_t sdkversion() const;
  void set_sdkversion(int32_t value);
  private:
  int32_t _internal_sdkversion() const;
  void _internal_set_sdkversion(int32_t value);
  public:

  // int32 platform = 11;
  void clear_platform();
  int32_t platform() const;
  void set_platform(int32_t value);
  private:
  int32_t _internal_platform() const;
  void _internal_set_platform(int32_t value);
  public:

  // int64 createTime = 12;
  void clear_createtime();
  int64_t createtime() const;
  void set_createtime(int64_t value);
  private:
  int64_t _internal_createtime() const;
  void _internal_set_createtime(int64_t value);
  public:

  // optional int64 isAppLicense = 17;
  bool has_isapplicense() const;
  private:
  bool _internal_has_isapplicense() const;
  public:
  void clear_isapplicense();
  int64_t isapplicense() const;
  void set_isapplicense(int64_t value);
  private:
  int64_t _internal_isapplicense() const;
  void _internal_set_isapplicense(int64_t value);
  public:

  // int32 callType = 21;
  void clear_calltype();
  int32_t calltype() const;
  void set_calltype(int32_t value);
  private:
  int32_t _internal_calltype() const;
  void _internal_set_calltype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Argus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msappid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr licenseid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdkversionstr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr envcode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bodyhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queryhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secdevicetoken_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pskhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pskcalhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pskversion_;
    ::ActionRecord* actionrecord_;
    int32_t magic_;
    int32_t version_;
    int64_t rand_;
    int32_t sdkversion_;
    int32_t platform_;
    int64_t createtime_;
    int64_t isapplicense_;
    int32_t calltype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_argus_2eproto;
};
// -------------------------------------------------------------------

class ActionRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ActionRecord) */ {
 public:
  inline ActionRecord() : ActionRecord(nullptr) {}
  ~ActionRecord() override;
  explicit PROTOBUF_CONSTEXPR ActionRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionRecord(const ActionRecord& from);
  ActionRecord(ActionRecord&& from) noexcept
    : ActionRecord() {
    *this = ::std::move(from);
  }

  inline ActionRecord& operator=(const ActionRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionRecord& operator=(ActionRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionRecord* internal_default_instance() {
    return reinterpret_cast<const ActionRecord*>(
               &_ActionRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ActionRecord& a, ActionRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionRecord& from) {
    ActionRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ActionRecord";
  }
  protected:
  explicit ActionRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignCountFieldNumber = 1,
    kReportCountFieldNumber = 2,
    kSettingCountFieldNumber = 3,
  };
  // int32 signCount = 1;
  void clear_signcount();
  int32_t signcount() const;
  void set_signcount(int32_t value);
  private:
  int32_t _internal_signcount() const;
  void _internal_set_signcount(int32_t value);
  public:

  // int32 reportCount = 2;
  void clear_reportcount();
  int32_t reportcount() const;
  void set_reportcount(int32_t value);
  private:
  int32_t _internal_reportcount() const;
  void _internal_set_reportcount(int32_t value);
  public:

  // int32 settingCount = 3;
  void clear_settingcount();
  int32_t settingcount() const;
  void set_settingcount(int32_t value);
  private:
  int32_t _internal_settingcount() const;
  void _internal_set_settingcount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ActionRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t signcount_;
    int32_t reportcount_;
    int32_t settingcount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_argus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Argus

// int32 magic = 1;
inline void Argus::clear_magic() {
  _impl_.magic_ = 0;
}
inline int32_t Argus::_internal_magic() const {
  return _impl_.magic_;
}
inline int32_t Argus::magic() const {
  // @@protoc_insertion_point(field_get:Argus.magic)
  return _internal_magic();
}
inline void Argus::_internal_set_magic(int32_t value) {
  
  _impl_.magic_ = value;
}
inline void Argus::set_magic(int32_t value) {
  _internal_set_magic(value);
  // @@protoc_insertion_point(field_set:Argus.magic)
}

// int32 version = 2;
inline void Argus::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t Argus::_internal_version() const {
  return _impl_.version_;
}
inline int32_t Argus::version() const {
  // @@protoc_insertion_point(field_get:Argus.version)
  return _internal_version();
}
inline void Argus::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void Argus::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:Argus.version)
}

// int64 rand = 3;
inline void Argus::clear_rand() {
  _impl_.rand_ = int64_t{0};
}
inline int64_t Argus::_internal_rand() const {
  return _impl_.rand_;
}
inline int64_t Argus::rand() const {
  // @@protoc_insertion_point(field_get:Argus.rand)
  return _internal_rand();
}
inline void Argus::_internal_set_rand(int64_t value) {
  
  _impl_.rand_ = value;
}
inline void Argus::set_rand(int64_t value) {
  _internal_set_rand(value);
  // @@protoc_insertion_point(field_set:Argus.rand)
}

// string msAppID = 4;
inline void Argus::clear_msappid() {
  _impl_.msappid_.ClearToEmpty();
}
inline const std::string& Argus::msappid() const {
  // @@protoc_insertion_point(field_get:Argus.msAppID)
  return _internal_msappid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_msappid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msappid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.msAppID)
}
inline std::string* Argus::mutable_msappid() {
  std::string* _s = _internal_mutable_msappid();
  // @@protoc_insertion_point(field_mutable:Argus.msAppID)
  return _s;
}
inline const std::string& Argus::_internal_msappid() const {
  return _impl_.msappid_.Get();
}
inline void Argus::_internal_set_msappid(const std::string& value) {
  
  _impl_.msappid_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_msappid() {
  
  return _impl_.msappid_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_msappid() {
  // @@protoc_insertion_point(field_release:Argus.msAppID)
  return _impl_.msappid_.Release();
}
inline void Argus::set_allocated_msappid(std::string* msappid) {
  if (msappid != nullptr) {
    
  } else {
    
  }
  _impl_.msappid_.SetAllocated(msappid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msappid_.IsDefault()) {
    _impl_.msappid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.msAppID)
}

// optional string deviceID = 5;
inline bool Argus::_internal_has_deviceid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Argus::has_deviceid() const {
  return _internal_has_deviceid();
}
inline void Argus::clear_deviceid() {
  _impl_.deviceid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Argus::deviceid() const {
  // @@protoc_insertion_point(field_get:Argus.deviceID)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_deviceid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.deviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.deviceID)
}
inline std::string* Argus::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:Argus.deviceID)
  return _s;
}
inline const std::string& Argus::_internal_deviceid() const {
  return _impl_.deviceid_.Get();
}
inline void Argus::_internal_set_deviceid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_deviceid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.deviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_deviceid() {
  // @@protoc_insertion_point(field_release:Argus.deviceID)
  if (!_internal_has_deviceid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.deviceid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Argus::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deviceid_.SetAllocated(deviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.deviceID)
}

// string licenseID = 6;
inline void Argus::clear_licenseid() {
  _impl_.licenseid_.ClearToEmpty();
}
inline const std::string& Argus::licenseid() const {
  // @@protoc_insertion_point(field_get:Argus.licenseID)
  return _internal_licenseid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_licenseid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.licenseid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.licenseID)
}
inline std::string* Argus::mutable_licenseid() {
  std::string* _s = _internal_mutable_licenseid();
  // @@protoc_insertion_point(field_mutable:Argus.licenseID)
  return _s;
}
inline const std::string& Argus::_internal_licenseid() const {
  return _impl_.licenseid_.Get();
}
inline void Argus::_internal_set_licenseid(const std::string& value) {
  
  _impl_.licenseid_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_licenseid() {
  
  return _impl_.licenseid_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_licenseid() {
  // @@protoc_insertion_point(field_release:Argus.licenseID)
  return _impl_.licenseid_.Release();
}
inline void Argus::set_allocated_licenseid(std::string* licenseid) {
  if (licenseid != nullptr) {
    
  } else {
    
  }
  _impl_.licenseid_.SetAllocated(licenseid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.licenseid_.IsDefault()) {
    _impl_.licenseid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.licenseID)
}

// optional string appVersion = 7;
inline bool Argus::_internal_has_appversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Argus::has_appversion() const {
  return _internal_has_appversion();
}
inline void Argus::clear_appversion() {
  _impl_.appversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Argus::appversion() const {
  // @@protoc_insertion_point(field_get:Argus.appVersion)
  return _internal_appversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_appversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.appversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.appVersion)
}
inline std::string* Argus::mutable_appversion() {
  std::string* _s = _internal_mutable_appversion();
  // @@protoc_insertion_point(field_mutable:Argus.appVersion)
  return _s;
}
inline const std::string& Argus::_internal_appversion() const {
  return _impl_.appversion_.Get();
}
inline void Argus::_internal_set_appversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.appversion_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_appversion() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.appversion_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_appversion() {
  // @@protoc_insertion_point(field_release:Argus.appVersion)
  if (!_internal_has_appversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.appversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appversion_.IsDefault()) {
    _impl_.appversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Argus::set_allocated_appversion(std::string* appversion) {
  if (appversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.appversion_.SetAllocated(appversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appversion_.IsDefault()) {
    _impl_.appversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.appVersion)
}

// string sdkVersionStr = 8;
inline void Argus::clear_sdkversionstr() {
  _impl_.sdkversionstr_.ClearToEmpty();
}
inline const std::string& Argus::sdkversionstr() const {
  // @@protoc_insertion_point(field_get:Argus.sdkVersionStr)
  return _internal_sdkversionstr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_sdkversionstr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdkversionstr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.sdkVersionStr)
}
inline std::string* Argus::mutable_sdkversionstr() {
  std::string* _s = _internal_mutable_sdkversionstr();
  // @@protoc_insertion_point(field_mutable:Argus.sdkVersionStr)
  return _s;
}
inline const std::string& Argus::_internal_sdkversionstr() const {
  return _impl_.sdkversionstr_.Get();
}
inline void Argus::_internal_set_sdkversionstr(const std::string& value) {
  
  _impl_.sdkversionstr_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_sdkversionstr() {
  
  return _impl_.sdkversionstr_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_sdkversionstr() {
  // @@protoc_insertion_point(field_release:Argus.sdkVersionStr)
  return _impl_.sdkversionstr_.Release();
}
inline void Argus::set_allocated_sdkversionstr(std::string* sdkversionstr) {
  if (sdkversionstr != nullptr) {
    
  } else {
    
  }
  _impl_.sdkversionstr_.SetAllocated(sdkversionstr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdkversionstr_.IsDefault()) {
    _impl_.sdkversionstr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.sdkVersionStr)
}

// int32 sdkVersion = 9;
inline void Argus::clear_sdkversion() {
  _impl_.sdkversion_ = 0;
}
inline int32_t Argus::_internal_sdkversion() const {
  return _impl_.sdkversion_;
}
inline int32_t Argus::sdkversion() const {
  // @@protoc_insertion_point(field_get:Argus.sdkVersion)
  return _internal_sdkversion();
}
inline void Argus::_internal_set_sdkversion(int32_t value) {
  
  _impl_.sdkversion_ = value;
}
inline void Argus::set_sdkversion(int32_t value) {
  _internal_set_sdkversion(value);
  // @@protoc_insertion_point(field_set:Argus.sdkVersion)
}

// bytes envCode = 10;
inline void Argus::clear_envcode() {
  _impl_.envcode_.ClearToEmpty();
}
inline const std::string& Argus::envcode() const {
  // @@protoc_insertion_point(field_get:Argus.envCode)
  return _internal_envcode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_envcode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.envcode_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.envCode)
}
inline std::string* Argus::mutable_envcode() {
  std::string* _s = _internal_mutable_envcode();
  // @@protoc_insertion_point(field_mutable:Argus.envCode)
  return _s;
}
inline const std::string& Argus::_internal_envcode() const {
  return _impl_.envcode_.Get();
}
inline void Argus::_internal_set_envcode(const std::string& value) {
  
  _impl_.envcode_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_envcode() {
  
  return _impl_.envcode_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_envcode() {
  // @@protoc_insertion_point(field_release:Argus.envCode)
  return _impl_.envcode_.Release();
}
inline void Argus::set_allocated_envcode(std::string* envcode) {
  if (envcode != nullptr) {
    
  } else {
    
  }
  _impl_.envcode_.SetAllocated(envcode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.envcode_.IsDefault()) {
    _impl_.envcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.envCode)
}

// int32 platform = 11;
inline void Argus::clear_platform() {
  _impl_.platform_ = 0;
}
inline int32_t Argus::_internal_platform() const {
  return _impl_.platform_;
}
inline int32_t Argus::platform() const {
  // @@protoc_insertion_point(field_get:Argus.platform)
  return _internal_platform();
}
inline void Argus::_internal_set_platform(int32_t value) {
  
  _impl_.platform_ = value;
}
inline void Argus::set_platform(int32_t value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:Argus.platform)
}

// int64 createTime = 12;
inline void Argus::clear_createtime() {
  _impl_.createtime_ = int64_t{0};
}
inline int64_t Argus::_internal_createtime() const {
  return _impl_.createtime_;
}
inline int64_t Argus::createtime() const {
  // @@protoc_insertion_point(field_get:Argus.createTime)
  return _internal_createtime();
}
inline void Argus::_internal_set_createtime(int64_t value) {
  
  _impl_.createtime_ = value;
}
inline void Argus::set_createtime(int64_t value) {
  _internal_set_createtime(value);
  // @@protoc_insertion_point(field_set:Argus.createTime)
}

// optional bytes bodyHash = 13;
inline bool Argus::_internal_has_bodyhash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Argus::has_bodyhash() const {
  return _internal_has_bodyhash();
}
inline void Argus::clear_bodyhash() {
  _impl_.bodyhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Argus::bodyhash() const {
  // @@protoc_insertion_point(field_get:Argus.bodyHash)
  return _internal_bodyhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_bodyhash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.bodyhash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.bodyHash)
}
inline std::string* Argus::mutable_bodyhash() {
  std::string* _s = _internal_mutable_bodyhash();
  // @@protoc_insertion_point(field_mutable:Argus.bodyHash)
  return _s;
}
inline const std::string& Argus::_internal_bodyhash() const {
  return _impl_.bodyhash_.Get();
}
inline void Argus::_internal_set_bodyhash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.bodyhash_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_bodyhash() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.bodyhash_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_bodyhash() {
  // @@protoc_insertion_point(field_release:Argus.bodyHash)
  if (!_internal_has_bodyhash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.bodyhash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bodyhash_.IsDefault()) {
    _impl_.bodyhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Argus::set_allocated_bodyhash(std::string* bodyhash) {
  if (bodyhash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.bodyhash_.SetAllocated(bodyhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bodyhash_.IsDefault()) {
    _impl_.bodyhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.bodyHash)
}

// optional bytes queryHash = 14;
inline bool Argus::_internal_has_queryhash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Argus::has_queryhash() const {
  return _internal_has_queryhash();
}
inline void Argus::clear_queryhash() {
  _impl_.queryhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Argus::queryhash() const {
  // @@protoc_insertion_point(field_get:Argus.queryHash)
  return _internal_queryhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_queryhash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.queryhash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.queryHash)
}
inline std::string* Argus::mutable_queryhash() {
  std::string* _s = _internal_mutable_queryhash();
  // @@protoc_insertion_point(field_mutable:Argus.queryHash)
  return _s;
}
inline const std::string& Argus::_internal_queryhash() const {
  return _impl_.queryhash_.Get();
}
inline void Argus::_internal_set_queryhash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.queryhash_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_queryhash() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.queryhash_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_queryhash() {
  // @@protoc_insertion_point(field_release:Argus.queryHash)
  if (!_internal_has_queryhash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.queryhash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.queryhash_.IsDefault()) {
    _impl_.queryhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Argus::set_allocated_queryhash(std::string* queryhash) {
  if (queryhash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.queryhash_.SetAllocated(queryhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.queryhash_.IsDefault()) {
    _impl_.queryhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.queryHash)
}

// .ActionRecord actionRecord = 15;
inline bool Argus::_internal_has_actionrecord() const {
  return this != internal_default_instance() && _impl_.actionrecord_ != nullptr;
}
inline bool Argus::has_actionrecord() const {
  return _internal_has_actionrecord();
}
inline void Argus::clear_actionrecord() {
  if (GetArenaForAllocation() == nullptr && _impl_.actionrecord_ != nullptr) {
    delete _impl_.actionrecord_;
  }
  _impl_.actionrecord_ = nullptr;
}
inline const ::ActionRecord& Argus::_internal_actionrecord() const {
  const ::ActionRecord* p = _impl_.actionrecord_;
  return p != nullptr ? *p : reinterpret_cast<const ::ActionRecord&>(
      ::_ActionRecord_default_instance_);
}
inline const ::ActionRecord& Argus::actionrecord() const {
  // @@protoc_insertion_point(field_get:Argus.actionRecord)
  return _internal_actionrecord();
}
inline void Argus::unsafe_arena_set_allocated_actionrecord(
    ::ActionRecord* actionrecord) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.actionrecord_);
  }
  _impl_.actionrecord_ = actionrecord;
  if (actionrecord) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Argus.actionRecord)
}
inline ::ActionRecord* Argus::release_actionrecord() {
  
  ::ActionRecord* temp = _impl_.actionrecord_;
  _impl_.actionrecord_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ActionRecord* Argus::unsafe_arena_release_actionrecord() {
  // @@protoc_insertion_point(field_release:Argus.actionRecord)
  
  ::ActionRecord* temp = _impl_.actionrecord_;
  _impl_.actionrecord_ = nullptr;
  return temp;
}
inline ::ActionRecord* Argus::_internal_mutable_actionrecord() {
  
  if (_impl_.actionrecord_ == nullptr) {
    auto* p = CreateMaybeMessage<::ActionRecord>(GetArenaForAllocation());
    _impl_.actionrecord_ = p;
  }
  return _impl_.actionrecord_;
}
inline ::ActionRecord* Argus::mutable_actionrecord() {
  ::ActionRecord* _msg = _internal_mutable_actionrecord();
  // @@protoc_insertion_point(field_mutable:Argus.actionRecord)
  return _msg;
}
inline void Argus::set_allocated_actionrecord(::ActionRecord* actionrecord) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.actionrecord_;
  }
  if (actionrecord) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(actionrecord);
    if (message_arena != submessage_arena) {
      actionrecord = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, actionrecord, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.actionrecord_ = actionrecord;
  // @@protoc_insertion_point(field_set_allocated:Argus.actionRecord)
}

// optional string secDeviceToken = 16;
inline bool Argus::_internal_has_secdevicetoken() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Argus::has_secdevicetoken() const {
  return _internal_has_secdevicetoken();
}
inline void Argus::clear_secdevicetoken() {
  _impl_.secdevicetoken_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Argus::secdevicetoken() const {
  // @@protoc_insertion_point(field_get:Argus.secDeviceToken)
  return _internal_secdevicetoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_secdevicetoken(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.secdevicetoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.secDeviceToken)
}
inline std::string* Argus::mutable_secdevicetoken() {
  std::string* _s = _internal_mutable_secdevicetoken();
  // @@protoc_insertion_point(field_mutable:Argus.secDeviceToken)
  return _s;
}
inline const std::string& Argus::_internal_secdevicetoken() const {
  return _impl_.secdevicetoken_.Get();
}
inline void Argus::_internal_set_secdevicetoken(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.secdevicetoken_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_secdevicetoken() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.secdevicetoken_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_secdevicetoken() {
  // @@protoc_insertion_point(field_release:Argus.secDeviceToken)
  if (!_internal_has_secdevicetoken()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.secdevicetoken_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secdevicetoken_.IsDefault()) {
    _impl_.secdevicetoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Argus::set_allocated_secdevicetoken(std::string* secdevicetoken) {
  if (secdevicetoken != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.secdevicetoken_.SetAllocated(secdevicetoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secdevicetoken_.IsDefault()) {
    _impl_.secdevicetoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.secDeviceToken)
}

// optional int64 isAppLicense = 17;
inline bool Argus::_internal_has_isapplicense() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Argus::has_isapplicense() const {
  return _internal_has_isapplicense();
}
inline void Argus::clear_isapplicense() {
  _impl_.isapplicense_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t Argus::_internal_isapplicense() const {
  return _impl_.isapplicense_;
}
inline int64_t Argus::isapplicense() const {
  // @@protoc_insertion_point(field_get:Argus.isAppLicense)
  return _internal_isapplicense();
}
inline void Argus::_internal_set_isapplicense(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.isapplicense_ = value;
}
inline void Argus::set_isapplicense(int64_t value) {
  _internal_set_isapplicense(value);
  // @@protoc_insertion_point(field_set:Argus.isAppLicense)
}

// optional bytes pskHash = 18;
inline bool Argus::_internal_has_pskhash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Argus::has_pskhash() const {
  return _internal_has_pskhash();
}
inline void Argus::clear_pskhash() {
  _impl_.pskhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Argus::pskhash() const {
  // @@protoc_insertion_point(field_get:Argus.pskHash)
  return _internal_pskhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_pskhash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.pskhash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.pskHash)
}
inline std::string* Argus::mutable_pskhash() {
  std::string* _s = _internal_mutable_pskhash();
  // @@protoc_insertion_point(field_mutable:Argus.pskHash)
  return _s;
}
inline const std::string& Argus::_internal_pskhash() const {
  return _impl_.pskhash_.Get();
}
inline void Argus::_internal_set_pskhash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.pskhash_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_pskhash() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.pskhash_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_pskhash() {
  // @@protoc_insertion_point(field_release:Argus.pskHash)
  if (!_internal_has_pskhash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.pskhash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pskhash_.IsDefault()) {
    _impl_.pskhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Argus::set_allocated_pskhash(std::string* pskhash) {
  if (pskhash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.pskhash_.SetAllocated(pskhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pskhash_.IsDefault()) {
    _impl_.pskhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.pskHash)
}

// optional bytes pskCalHash = 19;
inline bool Argus::_internal_has_pskcalhash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Argus::has_pskcalhash() const {
  return _internal_has_pskcalhash();
}
inline void Argus::clear_pskcalhash() {
  _impl_.pskcalhash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& Argus::pskcalhash() const {
  // @@protoc_insertion_point(field_get:Argus.pskCalHash)
  return _internal_pskcalhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_pskcalhash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.pskcalhash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.pskCalHash)
}
inline std::string* Argus::mutable_pskcalhash() {
  std::string* _s = _internal_mutable_pskcalhash();
  // @@protoc_insertion_point(field_mutable:Argus.pskCalHash)
  return _s;
}
inline const std::string& Argus::_internal_pskcalhash() const {
  return _impl_.pskcalhash_.Get();
}
inline void Argus::_internal_set_pskcalhash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.pskcalhash_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_pskcalhash() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.pskcalhash_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_pskcalhash() {
  // @@protoc_insertion_point(field_release:Argus.pskCalHash)
  if (!_internal_has_pskcalhash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.pskcalhash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pskcalhash_.IsDefault()) {
    _impl_.pskcalhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Argus::set_allocated_pskcalhash(std::string* pskcalhash) {
  if (pskcalhash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.pskcalhash_.SetAllocated(pskcalhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pskcalhash_.IsDefault()) {
    _impl_.pskcalhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.pskCalHash)
}

// string pskVersion = 20;
inline void Argus::clear_pskversion() {
  _impl_.pskversion_.ClearToEmpty();
}
inline const std::string& Argus::pskversion() const {
  // @@protoc_insertion_point(field_get:Argus.pskVersion)
  return _internal_pskversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Argus::set_pskversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pskversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Argus.pskVersion)
}
inline std::string* Argus::mutable_pskversion() {
  std::string* _s = _internal_mutable_pskversion();
  // @@protoc_insertion_point(field_mutable:Argus.pskVersion)
  return _s;
}
inline const std::string& Argus::_internal_pskversion() const {
  return _impl_.pskversion_.Get();
}
inline void Argus::_internal_set_pskversion(const std::string& value) {
  
  _impl_.pskversion_.Set(value, GetArenaForAllocation());
}
inline std::string* Argus::_internal_mutable_pskversion() {
  
  return _impl_.pskversion_.Mutable(GetArenaForAllocation());
}
inline std::string* Argus::release_pskversion() {
  // @@protoc_insertion_point(field_release:Argus.pskVersion)
  return _impl_.pskversion_.Release();
}
inline void Argus::set_allocated_pskversion(std::string* pskversion) {
  if (pskversion != nullptr) {
    
  } else {
    
  }
  _impl_.pskversion_.SetAllocated(pskversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pskversion_.IsDefault()) {
    _impl_.pskversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Argus.pskVersion)
}

// int32 callType = 21;
inline void Argus::clear_calltype() {
  _impl_.calltype_ = 0;
}
inline int32_t Argus::_internal_calltype() const {
  return _impl_.calltype_;
}
inline int32_t Argus::calltype() const {
  // @@protoc_insertion_point(field_get:Argus.callType)
  return _internal_calltype();
}
inline void Argus::_internal_set_calltype(int32_t value) {
  
  _impl_.calltype_ = value;
}
inline void Argus::set_calltype(int32_t value) {
  _internal_set_calltype(value);
  // @@protoc_insertion_point(field_set:Argus.callType)
}

// -------------------------------------------------------------------

// ActionRecord

// int32 signCount = 1;
inline void ActionRecord::clear_signcount() {
  _impl_.signcount_ = 0;
}
inline int32_t ActionRecord::_internal_signcount() const {
  return _impl_.signcount_;
}
inline int32_t ActionRecord::signcount() const {
  // @@protoc_insertion_point(field_get:ActionRecord.signCount)
  return _internal_signcount();
}
inline void ActionRecord::_internal_set_signcount(int32_t value) {
  
  _impl_.signcount_ = value;
}
inline void ActionRecord::set_signcount(int32_t value) {
  _internal_set_signcount(value);
  // @@protoc_insertion_point(field_set:ActionRecord.signCount)
}

// int32 reportCount = 2;
inline void ActionRecord::clear_reportcount() {
  _impl_.reportcount_ = 0;
}
inline int32_t ActionRecord::_internal_reportcount() const {
  return _impl_.reportcount_;
}
inline int32_t ActionRecord::reportcount() const {
  // @@protoc_insertion_point(field_get:ActionRecord.reportCount)
  return _internal_reportcount();
}
inline void ActionRecord::_internal_set_reportcount(int32_t value) {
  
  _impl_.reportcount_ = value;
}
inline void ActionRecord::set_reportcount(int32_t value) {
  _internal_set_reportcount(value);
  // @@protoc_insertion_point(field_set:ActionRecord.reportCount)
}

// int32 settingCount = 3;
inline void ActionRecord::clear_settingcount() {
  _impl_.settingcount_ = 0;
}
inline int32_t ActionRecord::_internal_settingcount() const {
  return _impl_.settingcount_;
}
inline int32_t ActionRecord::settingcount() const {
  // @@protoc_insertion_point(field_get:ActionRecord.settingCount)
  return _internal_settingcount();
}
inline void ActionRecord::_internal_set_settingcount(int32_t value) {
  
  _impl_.settingcount_ = value;
}
inline void ActionRecord::set_settingcount(int32_t value) {
  _internal_set_settingcount(value);
  // @@protoc_insertion_point(field_set:ActionRecord.settingCount)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_argus_2eproto
